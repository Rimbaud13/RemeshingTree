Function create_tree(mesh) :
    S = lowest vertex of each trunk
    Q = empty queue
    For each s in S : 
        push (s, s) into the queue
    End for
    create_tree_inner(Q)
End function

Function create_tree_inner(Q) :
    While Q is not empty :
        current_vertex, last_vertex = Q.pop()
        if current_vertex.abs_length > max_length :
            goto next iteration
        end if
        next = Empty set
        N = neighbors(current_vertex)
        For each n of N such that n is in a trunk:
            if current_vertex is in a trunk, and the trunk is the same trunk as n :
                add n to next
            else
                remove n from N
            end if
        end for
        For each n from N:
            current_branch_direction = current_vertex.pos - last_vertex.pos
            new_branch_direction = n.pos - current_vertex.pos
            if not dot(current_branch_direction, new_branch_direction) > min_dot_between_branches):
                remove n from N
            end if
        end for
        
        if N.size == 0:
            go to next iteration.
        end if
        
        if next.size < 2:
            split_count = 1 - next.size
            if current_vertex.rel_length >= min_rel_len_before_split and split(current_vertex) gives true:
                split_count += 1
            end if
            
            if next.size <= split_count:
                split_count = min(split_count, N.size)
                if split_count = 1:
                    if next.size = 0:
                        add the neighbor that would minimize the change of direction of the branch if followed
                    else :
                        take the branch that would have the greatest angle compared to the neighbor already present in next and add it to next
                    endif
                else :
                   take the two neighbors that have the maximum angle beteween them and add them to next.
                endif 
            endif
        endif
                  
        split_occured = next.size > 1
        
        For each vertex n of next:
            e = edge between current_vertex and n
            n.abs_length = current_vertex.abs_length + e.length
            if split_occured :
                n.rel_length = e.length
            else
                n.rel_length = current_vertex.rel_length + e.length
            endif
            add e to the wireframe with a scale going from the size of the current vertex to the size of n along the axis of the cylinder.
            add current_vertex to the wireframe with scale sphere_diameter * scale_factor(current_vertex.abs_length)
            push (current_vertex, n) to the queue
	end for
    End While
End function
